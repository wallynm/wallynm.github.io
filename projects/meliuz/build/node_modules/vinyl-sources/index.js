var File = require('vinyl');

// return true if `obj` can support properties; otherwise false
var isObject = function isObject(obj) {
  return Object(obj) === obj;
};

// returns a vinyl File that represents `maybeFile`, if maybeFile is already a vinyl File then
// it is returned; otherwise a vinyl file is constructed using the `file` as to hint at resolving
// the paths current working directory and base directory.
var normalizeSourceFile = function normalizeSourceFile(file, maybeFile) {

  // if it looks like a vinyl file just return it
  if (maybeFile.path != null) return maybeFile;

  return new File({ cwd: file.cwd, base: file.base, path: maybeFile });

};

var iterateSourcesCore = function iterateSourcesCore(file, callback, currentPath) {

  // return if no file supplied or it has no sources
  if (Array.isArray(file.sources) === false) return;

  // append the current file to the path so that recursive calls are correct
  currentPath = currentPath.concat(file);

  // iterate all of the File's sources calling iterate on each
  for (var i = 0; i < file.sources.length; i++) {
    var source = file.sources[i];

    // if the callback explicitely returns false we stop iteration
    if (callback(source, currentPath) === false) return;

    iterateSourcesCore(source, callback, currentPath);

  }

};

// normalizes and appends the sources to a given file
module.exports.record = function record(file, sources) {

  // jshint eqnull:true
  if (file == null) throw new TypeError('Parameter `file` must be provided');

  if (isObject(file) === false) throw new TypeError('Parameter `file` must be an object');

  if (Array.isArray(sources) === false) throw new TypeError('Parameter `sources` must be a mixed array');

  if (file.sources != null && Array.isArray(file.sources) === false)
    throw new TypeError('Parameter `file` contained a non-compatible sources property');

  // if the appending sources array is empty we avoid making changes to the vinyl file and just return early with an empty result
  if (sources.length === 0) return [];

  // if the file currently has no sources then initialize it
  if (file.sources == null) file.sources = [];

  var normalized = sources.map(normalizeSourceFile.bind(null, file));

  file.sources.push.apply(file.sources, normalized);

  return normalized;

};

// iterates a File's sources calling the `callback` parameter with each source as well as its path within the source hierarchy.
var iterateSources = module.exports.iterateSources = function iterateSources(file, callback) {

  // jshint eqnull:true
  if (file == null) throw new TypeError('Parameter `file` must be provided');

  if (isObject(file) === false) throw new TypeError('Parameter `file` must be an object');

  if (typeof callback !== 'function') throw new TypeError('Parameter `callback` must be a function');

  return iterateSourcesCore(file, callback, []);

};

// iterates a File's sources and returns each source within the source hierarchy.
module.exports.getSources = function getSources(file) {

  var sources = [];

  // we ignore the hierarchy of the source file, just iterate every file and record it
  // devnote: we specifically avoid trying to de-duplicate here, as each source will
  // be a vinyl file and reliable duplication checking would require checking that all
  // properties of a vinyl file match (path, cwd, base, contents, sources, sourcemap)
  iterateSources(file, function(source) {
    sources.push(source);
  });

  return sources;

};
